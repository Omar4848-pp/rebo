"use strict";

const utils = require("./utils");
const { generateUA } = require('./lib/userAgent');
const bypassAutoBehavior = require('./lib/bypassAutoBehavior');
const cheerio = require('cheerio');
const readline = require('readline');
const deasync = require('deasync');
const log = require("npmlog");

let checkVerified = null;

function setOptions(globalOptions, options) {
  Object.keys(options).map(function (key) {
  	switch (key) {
  		case 'online':
  			globalOptions.online = Boolean(options.online);
  			break;
  		case 'logLevel':
  			globalOptions.logLevel = options.logLevel;
  			break;
  		case 'logRecordSize':
  			globalOptions.logRecordSize = options.logRecordSize;
  			break;
  		case 'selfListen':
  			globalOptions.selfListen = Boolean(options.selfListen);
  			break;
  		case 'selfListenEvent':
  			globalOptions.selfListenEvent = options.selfListenEvent;
  			break;
  		case 'listenEvents':
  			globalOptions.listenEvents = Boolean(options.listenEvents);
  			break;
  		case 'updatePresence':
         globalOptions.updatePresence = Boolean(options.updatePresence);
  				break;
		case 'forceLogin':
				globalOptions.forceLogin = Boolean(options.forceLogin);
				break;
  		case 'userAgent':

globalOptions.userAgent = options.userAgent;
  			break;
  		case 'autoMarkDelivery':
  			globalOptions.autoMarkDelivery = Boolean(options.autoMarkDelivery);
  			break;
  		case 'autoMarkRead':
  			globalOptions.autoMarkRead = Boolean(options.autoMarkRead);
  			break;
  		case 'listenTyping':
  			globalOptions.listenTyping = Boolean(options.listenTyping);
  			break;
  		case 'proxy':
  			if (typeof options.proxy != "string") {
  				delete globalOptions.proxy;
  				utils.setProxy();
  			} else {
  				globalOptions.proxy = options.proxy;
  				utils.setProxy(globalOptions.proxy);
  			}
  			break;
  		case 'autoReconnect':
  			globalOptions.autoReconnect = Boolean(options.autoReconnect);
  			break;
  		case 'emitReady':
  			globalOptions.emitReady = Boolean(options.emitReady);
  			break;
  		default:
  			log.warn("Unrecognized option given to setOptions: " + key);
  			break;
  	}
  });
}

function buildAPI(globalOptions, html, jar) {
  const fb_dtsg = utils.getFroms(html, '["DTSGInitData",[],{"token":"', '","')[0];
  const maybeCookie = jar.getCookies("https://www.facebook.com").filter(function(val) {
      return val.cookieString().split("=")[0] === "c_user";
  });

  if (maybeCookie.length === 0) throw { error: "Error retrieving userID. This can be caused by a lot of things, including getting blocked by Facebook for logging in from an unknown location. Try logging in with a browser to verify." };
  if (html.indexOf("/checkpoint/block/?next") > -1) log.warn("login", "Checkpoint detected. Please log in with a browser to verify.");

  const userID = maybeCookie[0].cookieString().split("=")[1].toString();
  log.info("login", `Logged in as ${userID}`);
  
  try {
      clearInterval(checkVerified);
  } catch (_) { }

  const clientID = (Math.random() * 2147483648 | 0).toString(16);

  const CHECK_MQTT = {
      oldFBMQTTMatch: html.match(/irisSeqID:"(.+?)",appID:219994525426954,endpoint:"(.+?)"/),
      newFBMQTTMatch: html.match(/{"app_id":"219994525426954","endpoint":"(.+?)","iris_seq_id":"(.+?)"}/),
      legacyFBMQTTMatch: html.match(/$$"MqttWebConfig",\[$$,{"fbid":"(.*?)","appID":219994525426954,"endpoint":"(.*?)","pollingEndpoint":"(.*?)"/)
  }

  let Slot = Object.keys(CHECK_MQTT);
  let mqttEndpoint, region, irisSeqID;
  Object.keys(CHECK_MQTT).map(function(MQTT) {
      if (CHECK_MQTT[MQTT] && !region) {
          switch (Slot.indexOf(MQTT)) {
              case 0: {
                  irisSeqID = CHECK_MQTT[MQTT][1];
                  mqttEndpoint = CHECK_MQTT[MQTT][2].replace(/\\\//g, "/");
                  region = new URL(mqttEndpoint).searchParams.get("region").toUpperCase();
                  return;
              }
              case 1: {
                  irisSeqID = CHECK_MQTT[MQTT][2];
                  mqttEndpoint = CHECK_MQTT[MQTT][1].replace(/\\\//g, "/");
                  region = new URL(mqttEndpoint).searchParams.get("region").toUpperCase();
                  return;
              }
              case 2: {
                  mqttEndpoint = CHECK_MQTT[MQTT][2].replace(/\\\//g, "/");
                  region = new URL(mqttEndpoint).searchParams.get("region").toUpperCase();
                  return;
              }
          }
          return;
      }
  });   

  if (!region) region = 'pnb';
  if (!mqttEndpoint) mqttEndpoint = "wss://edge-chat.facebook.com/chat?region=" + region;
  log.info("login", `Server region ${region.toUpperCase()}`);
   
  const ctx = {
      userID: userID,
      jar: jar,
      clientID: clientID,
      globalOptions: globalOptions,
      loggedIn: true,
      access_token: 'NONE',
      clientMutationId: 0,
      mqttClient: undefined,
      lastSeqId: irisSeqID,
      syncToken: undefined,
      mqttEndpoint: mqttEndpoint,
      region: region,
      firstListen: true,
      req_ID: 0,
      callback_Task: {},
      fb_dtsg
  };

  const api = {
      setOptions: setOptions.bind(null, globalOptions),
      getAppState: function getAppState() {
  		const appState = utils.getAppState(jar);
  		return appState.filter((item, index, self) => self.findIndex((t) => { return t.key === item.key }) === index);
  	}
  };
  
  if (!region || !mqttEndpoint) api["htmlData"] = html;
  
  const defaultFuncs = utils.makeDefaults(html, userID, ctx);

  require('fs').readdirSync(__dirname + '/src/')
   .filter((v) => v.endsWith('.js'))
   .map((v) => {
     const functionName = v.replace('.js', ''); 
     api[functionName] = require('./src/' + v)(defaultFuncs, api, ctx);
   });
  
  return { ctx: ctx, defaultFuncs: defaultFuncs, api: api };
}

function makeLogin(jar, email, password, loginOptions) {
   return function(res) {
       const html = res.body;
       const $ = cheerio.load(html);
       let arr = [];

       $("#login_form input").map((i, v) => arr.push({ val: $(v).val(), name: $(v).attr("name") }));
       arr = arr.filter(v => v.val && v.val.length);

       const form = utils.arrToForm(arr);
       form.lsd = utils.getFrom(html, "[\"LSD\",[],{\"token\":\"", "\"}");
       form.lgndim = Buffer.from("{\"w\":1440,\"h\":900,\"aw\":1440,\"ah\":834,\"c\":24}").toString('base64');
       form.email = email;
       form.pass = password;
       form.default_persistent = '0';
       form.locale = 'en_US';     
       form.timezone = '240';
       form.lgnjs = ~~(Date.now() / 1000);

       html.split("\"_js_").slice(1).map((val) => {
           jar.setCookie(utils.formatCookie(JSON.parse("[\"" + utils.getFrom(val, "", "]") + "]"), "facebook"), "https://www.facebook.com")
       });

       return utils
           .post("https://www.facebook.com/login/device-based/regular/login/?login_attempt=1&lwv=110", jar, form, loginOptions)
           .then(utils.saveCookies(jar))
           .then(function(res) {
               const headers = res.headers;
               if (!headers.location) throw { error: "Invalid username/password." };

               if (headers.location.indexOf('https://www.facebook.com/checkpoint/') > -1) {
                   return handle2FA(headers, jar, form, loginOptions);
               }
               return utils.get('https://www.facebook.com/', jar, null, loginOptions).then(utils.saveCookies(jar));
           });
   };
}

function handle2FA(headers, jar, form, loginOptions) {
   const nextURL = 'https://www.facebook.com/checkpoint/?next=https%3A%2F%2Fwww.facebook.com%2Fhome.php';
   
   return utils
       .get(headers.location, jar, null, loginOptions)
       .then(utils.saveCookies(jar))
       .then(function(res) {
           const html = res.body;
           const $ = cheerio.load(html);
           let arr = [];

           $("form input").map((i, v) => arr.push({ val: $(v).val(), name: $(v).attr("name") }));
           arr = arr.filter(v => v.val && v.val.length);
           form = utils.arrToForm(arr);

           if (html.indexOf("checkpoint/?next") > -1) {
               const code = promptFor2FACode();
               return submit2FACode(code, form, jar, nextURL, loginOptions);
           }
       });
}

function promptFor2FACode() {
   const rl = readline.createInterface({
       input: process.stdin,
       output: process.stdout
   });
   let done, code;
   rl.question("Enter 2FA code: ", answer => {
       rl.close();
       code = answer;
       done = true;
   });
   deasync.loopWhile(() => !done);
   return code;
}

function submit2FACode(code, form, jar, nextURL, loginOptions) {
   form.approvals_code = code;
   form['submit[Continue]'] = "Continue";
   
   return utils
       .post(nextURL, jar, form, loginOptions)
       .then(utils.saveCookies(jar))
       .then(function() {
           delete form.no_fido;
           delete form.approvals_code;
           form.name_action_selected = 'save_device';
           return utils.post(nextURL, jar, form, loginOptions).then(utils.saveCookies(jar));
       })
       .then(function(res) {
           if (!res.headers.location && res.headers['set-cookie'][0].includes('checkpoint')) {
               throw { error: "Failed to verify 2FA code." };
           }
           return utils.get('https://www.facebook.com/', jar, null, loginOptions).then(utils.saveCookies(jar));
       });
}

function loginHelper(appState, email, password, globalOptions, callback, prCallback) {
   let mainPromise = null;
   const jar = utils.getJar();

   if (appState) {
       if (utils.getType(appState) === 'Array' && appState.some(c => c.name)) {
           appState = appState.map(c => {
               c.key = c.name;
               delete c.name;
               return c;
           })
       }
       else if (utils.getType(appState) === 'String') {
           const arrayAppState = [];
           appState.split(';').forEach(c => {
               const [key, value] = c.split('=');
               arrayAppState.push({
                   key: (key || "").trim(),
                   value: (value || "").trim(),
                   domain: ".facebook.com",
                   path: "/",
                   expires: new Date().getTime() + 1000 * 60 * 60 * 24 * 365
               });
           });
           appState = arrayAppState;
       }

       appState.map(function(c) {
           const str = c.key + "=" + c.value + "; expires=" + c.expires + "; domain=" + c.domain + "; path=" + c.path + ";";
           jar.setCookie(str, "http://" + c.domain);
       });
       
       mainPromise = utils
           .get('https://www.facebook.com/', jar, null, globalOptions, { noRef: true })
           .then(utils.saveCookies(jar));
   } else if (email && password) {
       mainPromise = utils
           .get('https://www.facebook.com/', jar, null, globalOptions)
           .then(utils.saveCookies(jar))
           .then(makeLogin(jar, email, password, globalOptions));
   } else {
       throw { error: "Please provide either appState or email and password." };
   }

   let ctx, api;
   mainPromise = mainPromise
.then(async function(res) {
        try {
            const bypassResult = await bypassAutoBehavior(res, jar, globalOptions, appState);
            const finalRes = bypassResult || res;
            
            const html = finalRes.body;
            const Obj = buildAPI(globalOptions, html, jar);
            ctx = Obj.ctx;
            api = Obj.api;
            return finalRes;
        } catch (e) {
            log.error("login", "Error in bypass:", e);
            const html = res.body;
            const Obj = buildAPI(globalOptions, html, jar);
            ctx = Obj.ctx;
            api = Obj.api;
            return res;
        }
    });

   mainPromise
       .then(function() {
           log.info("login", 'Done logging in.');
           log.info("login",
'Fixed by Jr Busaco');
           return callback(null, api);
       })
       .catch(function(e) {
           log.error("login", e.error || e);
           callback(e);
       });
}

function logUA() {
   const ua = generateUA();
   log.info("login", `Using User-Agent: ${ua}`);
   return ua;
}

function login(loginData, options, callback) {
  if (utils.getType(options) === 'Function' || utils.getType(options) === 'AsyncFunction') {
      callback = options;
      options = {};
  }

   const globalOptions = {
       forceLogin: true,
       selfListen: false,
       listenEvents: true,
       listenTyping: false,
       updatePresence: false,
       autoMarkDelivery: false,
       autoMarkRead: false,
       autoReconnect: false,
       logRecordSize: 100,
       online: false,
       emitReady: false,
       userAgent: logUA()
   };

   setOptions(globalOptions, options);  

   let prCallback = null;
   let returnPromise = null;
   if (utils.getType(callback) !== "Function" && utils.getType(callback) !== "AsyncFunction") {
       let rejectFunc = null;
       let resolveFunc = null;
       returnPromise = new Promise(function(resolve, reject) {
           resolveFunc = resolve;
           rejectFunc = reject;
       });
       prCallback = function(error, api) {
           if (error) return rejectFunc(error);
           return resolveFunc(api);
       };
       callback = prCallback;
   }
   loginHelper(loginData.appState, loginData.email, loginData.password, globalOptions, callback, prCallback);
   return returnPromise;
}

module.exports = login;
